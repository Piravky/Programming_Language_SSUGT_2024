# Лаораторная работа № 6 - Работа с файлами

**Время выполнения - 6 часа**

## Содержание

___

1. [Общие теоретические сведения](#общие-теоретические-сведения)
2. [Практические задания](#практические-задания)
3. [Задания для самостоятельного выполнения (по вариантам)](#задания-для-самостоятельного-выполнения-по-вариантам)
    * [Задание 1](#задание-1-написать-программу)
    * [Задание 2](#задание-2-написать-программу)
    * [Задание 3](#задание-3-написать-программу)
4. [Контрольные вопросы](#контрольные-вопросы)
5. [Содержание отчета](#содержание-отчета)

## Цель работы:

___

## Задачи работы:

___

1.

## Общие теоретические сведения

___

В языке Python широко используются файлы для выполнения операций с данными, которые предполагается хранить длительное
время.
Для работы с файлами используется специальный объект файла, который содержит методы для чтения данных из файла и записи
данных в файл.

Открыть файл можно с помощью встроенной функции `open()`:

`open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)`

Функция открывает файл и возвращает соответствующий файловый объект для последующего оперирования с ним.

Если файл не может быть открыт – вызывается исключение `OSError`

* `file` – единственный обязательный параметр, задает имя как текстового, так и двоичного файла (и путь к файлу, если
  файл
  не находится в текущем каталоге). Также этот параметр может указывать дескриптор файла в виде целого числа. Если задан
  дескрипртор файла, то он закрывается, когда закрывается файл (в том случае, если аргумент closefd не равен False);
* `mode` – задает режимы открытия файла:
    * `w` – открывает файл только для записи, если такой файл уже существует – его содержимое будет перезаписано, т.е.
      размер текущего файлоа будет уменьшен до нуля (truncating), иначе – создается новый файл для записи;
    * `r` – открыть файл только для чтения (значение по умолчанию, синоним `rt`), указатель устанавливается в начало
      файла, если файл не найден – возникает исключение FileNotFoundError;
    * `a` – открыть файл для добавления, если файл существует – предыдущее содержимое файла сохраняется и указатель
      устанавливается в конец файла (независимо от текущего положения указателя файла), иначе – файл создается для
      записи;
    * `b` – режим двоичных данных;
    * `t` – режим текстовых данных (значение по умолчанию);
    * `+` – открыть файл для чтения или записи, указатель устанавливается в начало файла. Различие между режимами
      `w+`, `w+b` и `r+`, `r+b` следующее – если указанный файл существует, то в первом случае его содержимое
      очищается (размер становится равным нулю), а во втором случае – нет;
    * `x` – при попытке открыть для записи существующий файл возникает исключение `FileExistsError` (параметр введен
      начиная с версии Python 3.3);

(значения `w`, `r`, `a`, `b`, `t`, `+` и `x` при совместном использовании могут указываться в произвольном
порядке). Python поддерживает два вида файлов – двоичные, при открытии которых для аргумента mode указано
значение `b`, и текстовые, при открытии которых аргумент mode не имеет значения `b`. Текстовые файлы возвращают
содержимое в виде строк, а двоичные файлы – в виде объектов типа bytes

* `buffering` – устанавливает размер буфера при работе с файлом:
    * если размер равен 0 (только для двоичных файлов), то режим буферизации не используется и операции чтения и записи
      выполняются напрямую с диска на диск;
    * если размер равен 1 (только для текстовых файлов), то используется построковая буферизация (значение по
      умолчанию);
    * если размер больше 1, то для двоичных файлов устанавливается размер буфера, т.е. размер блоков, на которые делится
      файл. Размер буфера выбирается исходя из параметров устройств обмена с целью оптимизации выполнения файловых
      операций. По умолчанию его размер равен значению `io.DEFAULT_BUFFER_SIZE`:
    ```python
    import io
    io.DEFAULT_BUFFER_SIZE
    8192
    ```

* `encoding` – указывает тип кодировки (используется только для текстовых файлов). Значение по умолчанию можно получить,
  используя метод `locale.getpreferredencoding()`:

```python
import locale

locale.getpreferredencoding()
'cp1251'
```

* `errors` – указывает, как будут обрабатываться ошибки кодирования и декодирования (только для текстового режима):
    * если параметр не указан или указано значение `strict` – при ошибке вырабатывается исключение `ValueError`;
    * `ignore` – игнорирует ошибку;
    * `replace` – вызывает установку маркера (например, "?") в том месте, где произошла ошибка;
    * `xmlcharrefreplace` – заменяет соответствующим XML-символом;
    * `backslashreplace` – заменяет ESC-последовательностью с обратным слэшем;
* `newline` – определяет, как будут обрабатываться символы конца строки:
    * если параметр не указан или указано значение `None` – осуществляется следующая трансляция символов конца строки:
      при записи в файл – символ `\n` преобразуется в форму, специфичную для платформы (`\n` для Unix и `\r\n` для Windows),
      при чтении из файла: из формы, специфичной для платформы в символ `\n`;
    * если указан параметр `''`, трансляция символов конца строки не выполняется;
* `closefd` – определяет, будет ли закрыт дескриптор файла после закрытия файла:
  * если `closefd = True` (значение по умолчанию) – будет; 
  * если `closefd = False` – нет;
* `opener` – указывает объект ABC-класса `callable` (например, функцию), который может быть использован для открытия файла.

Тип файла устанавливается при его открытии в соответствии с указанными значениями аргументов `mode` и `buffering` функции `open()`:

* текстовый файл (класс `_io.TextIOWrapper`) – все режимы, в которых аргумент mode не содержит признак `b` (`binary`); 
* двоичный файл с буферизацией для записи (класс `_io.BufferedWriter`) – `mode='wb'` или `mode='ab'` и `buffering<>0`; 
* двоичный файл с буферизацией для чтения (класс `_io.BufferedReader`) – `mode='rb'` и `buffering<>0`; 
* двоичный файл с буферизацией для записи и чтения (класс `_io.BufferedRandom`) – все режимы, в которых параметр mode содержит признаки `b+` и `buffering<>0`; 
* двоичный файл без буферизации (класс `_io.FileIO`) – все режимы, в которых аргумент mode содержит признак `b` и `buffering=0`.

Текстовые файлы отличаются тем, что содержат строки, осуществляют кодирование и декодирование символов и обработку символов новой строки.
Пример открытия текстового файла для записи:

```python
f= open ( 'text.txt' , 'w' )
```

Указав ссылку на файл, можно определить его параметры
```jupyter
>>>f
<_io.TextIOWrapper name='text.txt' mode='w' encoding='cp1251'> 
```

т.е. это:
* текстовый файл класса io.TextIOWrapper;
* режим работы – запись;
* кодировка символов – 'cp1251'.

После создания текстового файла для работы с ним могут быть использованы следующие методы:

|          **Метод**          | **Описание**                                                                                       |
|:---------------------------:|:---------------------------------------------------------------------------------------------------|
|       `file.close()`        | закрывает открытый файл                                                                            |
|       `file.fileno()`       | возвращает целочисленный дескриптор файла                                                          |
|      `file.flush()`         | очищает внутренний буфер                                                                           |
|       `file.isatty()`       | возвращает True, если файл привязан к терминалу                                                    |
|        `file.next()`        | возвращает следующую строку файла                                                                  |
|       `file.read(n)`        | чтение первых n символов файла                                                                     |
|      `file.readline()`      | читает одну строчку строки или файла                                                               |
|     `file.readlines()`      | читает и возвращает список всех строк в файле                                                      |
| `file.seek(offset[,whene])` | устанавливает текущую позицию в файле                                                              |
|      `file.seekable()`      | проверяет, поддерживает ли файл случайный доступ. Возвращает True, если да                         |
|        `file.tell()`        | возвращает текущую позицию в файле                                                                 |
|     `file.truncate(n)`      | уменьшает размер файл. Если n указала, то файл обрезается до n байт, если нет — до текущей позиции |
|      `file.write(str)`      | добавляет строку str в файл                                                                        |
| `file.writelines(sequence)` | добавляет последовательность строк в файл                                                          |



## Задания для самостоятельного выполнения (по вариантам)

___

### Задание 1. Написать программу

| **Вариант** | **Файл**                      |
|:-----------:|:------------------------------|
|      1      | [01.pos](../misc/lab6/01.pos) |
|      2      | [02.pos](../misc/lab6/02.pos) |
|      3      | [03.pos](../misc/lab6/03.pos) |
|      4      | [04.pos](../misc/lab6/04.pos) |
|      5      | [05.pos](../misc/lab6/05.pos) |
|      6      | [06.pos](../misc/lab6/06.pos) |
|      7      | [07.pos](../misc/lab6/07.pos) |
|      8      | [08.pos](../misc/lab6/08.pos) |
|      9      | [09.pos](../misc/lab6/09.pos) |
|     10      | [10.pos](../misc/lab6/10.pos) |
|     11      | [11.pos](../misc/lab6/11.pos) |
|     12      | [12.pos](../misc/lab6/12.pos) |
|     13      | [13.pos](../misc/lab6/13.pos) |
|     14      | [14.pos](../misc/lab6/14.pos) |
|     15      | [15.pos](../misc/lab6/15.pos) |

## Контрольные вопросы

___

1.

## Содержание отчета

___

1. Титульный лист
2. Цель и задачи работы
3. Задание
4. Описание выполнения алгоритма
5. Исходный код программы
6. Результаты работы программы
7. Ответы на контрольные вопросы.
8. Общий вывод о проделанной работе.